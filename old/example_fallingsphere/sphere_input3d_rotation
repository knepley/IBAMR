// physical parameters
R  = 0.3125
MU = 0.05
RHO = 2.0

// grid spacing parameters
MAX_LEVELS = 3        // maximum number of levels in locally refined grid
REF_RATIO  = 4        // refinement ratio between levels
REF_RATIO_FINEST = 4  // refinement ratio for the finest level.

N = 16                                   // coarsest grid spacing
NFINEST = (REF_RATIO^(MAX_LEVELS - 1))*N  // finest   grid spacing
L = 16

VelocityInitialConditions {
   function_0 = "0.0"
   function_1 = "0.0"
   function_2 = "0.0"
   
}

VelocityBcCoefs_0 {

   acoef_function_0 = "1.0"
   acoef_function_1 = "1.0"
   acoef_function_2 = "1.0"
   acoef_function_3 = "1.0"
   acoef_function_4 = "1.0"
   acoef_function_5 = "1.0"

   bcoef_function_0 = "0.0"
   bcoef_function_1 = "0.0"
   bcoef_function_2 = "0.0"
   bcoef_function_3 = "0.0"
   bcoef_function_4 = "0.0"
   bcoef_function_5 = "0.0"


   gcoef_function_0 = "0.0"
   gcoef_function_1 = "0.0"
   gcoef_function_2 = "0.0"
   gcoef_function_3 = "0.0"
   gcoef_function_4 = "0.0"
   gcoef_function_5 = "0.0"

}

VelocityBcCoefs_1 {

   acoef_function_0 = "1.0"
   acoef_function_1 = "1.0"
   acoef_function_2 = "1.0"
   acoef_function_3 = "1.0"
   acoef_function_4 = "1.0"
   acoef_function_5 = "1.0"

   bcoef_function_0 = "0.0"
   bcoef_function_1 = "0.0"
   bcoef_function_2 = "0.0"
   bcoef_function_3 = "0.0"
   bcoef_function_4 = "0.0"
   bcoef_function_5 = "0.0"


   gcoef_function_0 = "0.0"
   gcoef_function_1 = "0.0"
   gcoef_function_2 = "0.0"
   gcoef_function_3 = "0.0"
   gcoef_function_4 = "0.0"
   gcoef_function_5 = "0.0"

}

VelocityBcCoefs_2 {

   acoef_function_0 = "1.0"
   acoef_function_1 = "1.0"
   acoef_function_2 = "1.0"
   acoef_function_3 = "1.0"
   acoef_function_4 = "1.0"
   acoef_function_5 = "1.0"

   bcoef_function_0 = "0.0"
   bcoef_function_1 = "0.0"
   bcoef_function_2 = "0.0"
   bcoef_function_3 = "0.0"
   bcoef_function_4 = "0.0"
   bcoef_function_5 = "0.0"


   gcoef_function_0 = "0.0"
   gcoef_function_1 = "0.0"
   gcoef_function_2 = "0.0"
   gcoef_function_3 = "0.0"
   gcoef_function_4 = "0.0"
   gcoef_function_5 = "0.0"

}


// Simulation Parameters
START_TIME           =   0.0e0     // initial simulation time
END_TIME             =   130.0e0    // final simulation time
GROW_DT              =   2.0e0     // growth factor for timesteps
MAX_INTEGRATOR_STEPS =   4  // max number of simulation timesteps
REGRID_INTERVAL      =   1
CFL                  =   0.3   
NUM_INS_CYCLES       =   2

IBStaggeredHierarchyIntegrator {
   start_time            = START_TIME            // initial simulation time
   end_time              = END_TIME              // final simulation time
   grow_dt               = GROW_DT               // growth factor for timesteps
   max_integrator_steps  = MAX_INTEGRATOR_STEPS   // max number of simulation timesteps
   regrid_interval       = REGRID_INTERVAL
   
   dt_max   = 0.002
   num_cycles = NUM_INS_CYCLES
   delta_fcn = "IB_4"
   enable_logging = TRUE
}

LEInteractor {
   debug_sort_mode = "NO_SORT"
   precision_mode  = "DOUBLE"
}

PETScVecOps {
   sort_mode      = "SORT_DECREASING_MAGNITUDE"
   precision_mode = "DOUBLE_DOUBLE"
   summation_mode = "COMPENSATED_SUMMATION"
}

IBStandardInitializer {
   max_levels = MAX_LEVELS
   base_filenames_2 = "sphere3d"
}

DyeInitialConditions {
  
   // circular region parameters.
   XCOM = -0.1336
   YCOM = 1.2631
   RADIUS = 1.3
   EPS    = 0.05

  // Rectangular region parameters
   xrec_cm      = -1.5
   yrec_cm      = 0.1
   l            = 1.25  // length/4
   b            = 0.15  // breadth/4

   //function = "if(sqrt((X0 - XCOM)^2 + (X1-YCOM+RADIUS)^2) < RADIUS + EPS, 1, 0)"  //circle
   function =    "if( rint(  abs( abs(X0 - xrec_cm)  - l) / l - 0.5 ) +  rint(  abs( abs(X1 -yrec_cm) - b) / b - 0.5 )  == 0    , 1, 0)"  //rectangle
}


DyeBoundaryConditions {
   acoef_function_0 = "0.0" // Q_acoef_0
   acoef_function_1 = "0.0" // Q_acoef_1
   acoef_function_2 = "0.0" // Q_acoef_2
   acoef_function_3 = "0.0" // Q_acoef_3

   bcoef_function_0 = "1.0" // Q_bcoef_0
   bcoef_function_1 = "1.0" // Q_bcoef_1
   bcoef_function_2 = "1.0" // Q_bcoef_2
   bcoef_function_3 = "1.0" // Q_bcoef_3

   gcoef_function_0 = "0.0" // Q_gcoef_0
   gcoef_function_1 = "0.0" // Q_gcoef_1
   gcoef_function_2 = "0.0" // Q_gcoef_2
   gcoef_function_3 = "0.0" // Q_gcoef_3
}


GodunovAdvector {
}


AdvDiffHierarchyIntegrator {
   start_time           = START_TIME
   end_time             = END_TIME
   grow_dt              = GROW_DT
   max_integrator_steps = MAX_INTEGRATOR_STEPS
   regrid_interval      = REGRID_INTERVAL

   enable_logging = TRUE

   tag_buffer = 1

   AdvDiffHypPatchOps {
      compute_init_velocity  = TRUE
      compute_half_velocity  = TRUE
      compute_final_velocity = FALSE
      extrap_type = "LINEAR"

      Refinement_data {
         refine_criteria = "QVAL_GRADIENT"

         QVAL_GRADIENT {
            grad_tol = 1.0
         }
      }
   }

   HyperbolicLevelIntegrator {
      cfl                      = CFL  // max cfl factor used in problem
      cfl_init                 = CFL  // initial cfl factor
      lag_dt_computation       = TRUE
      use_ghosts_to_compute_dt = FALSE
   }

   max_iterations = 50
   abs_residual_tol = 1.0e-30
   rel_residual_tol = 1.0e-6
   using_FAC = TRUE

   FACOps {
      fac_max_cycles = 1
      fac_uses_presmoothing = FALSE
      fac_initial_guess_nonzero = FALSE

      skip_restrict_sol = TRUE
      skip_restrict_residual = FALSE

      ssor_iterations = 1

      coarse_solver_choice = "block_jacobi"
      coarse_solver_tolerance = 1.0e-6
      coarse_solver_max_iterations = 1
      prolongation_method = "LINEAR_REFINE"
      cf_discretization   = "LINEAR_REFINE"
   }

   FACPreconditioners {
      max_cycles = 1
      residual_tol = 1.0e-12
      num_pre_sweeps  = 0  // this should always be 0
      num_post_sweeps = 3
   }
}



INSStaggeredHierarchyIntegrator {
   enable_logging = TRUE

   //cfl = 0.4875
   cfl = CFL

   tag_buffer = 2

   using_vorticity_tagging = TRUE
   vorticity_rel_thresh = 0.25

   output_U = TRUE
   output_P = TRUE
   output_F = TRUE
   output_Omega = TRUE
   output_Div_U = FALSE

   mu  = MU
   rho = RHO

   normalize_pressure = TRUE

   HelmholtzHypreSolver {
      solver_type           = "Split"
      split_solver_type     = "PFMG"
      relative_residual_tol = 1.0e-12
      max_iterations        = 1
      enable_logging        = FALSE
   }

   HelmholtzFACSolver {
      num_pre_sweeps  = 2
      num_post_sweeps = 2
      coarse_solver_choice = "block_jacobi"
      coarse_solver_tolerance = 1.0e-12
      coarse_solver_max_iterations = 2
      prolongation_method = "CONSTANT_REFINE"
      restriction_method  = "CONSERVATIVE_COARSEN"
   }

   PoissonHypreSolver {
      solver_type           = "PFMG"
      rap_type              = 0
      relax_type            = 2
      skip_relax            = 0
      num_pre_relax_steps   = 2
      num_post_relax_steps  = 2
      relative_residual_tol = 1.0e-12
      max_iterations        = 1
      enable_logging        = FALSE
   }

   PoissonFACSolver {
      num_pre_sweeps  = 0
      num_post_sweeps = 2
      coarse_solver_choice = "hypre"
      coarse_solver_tolerance = 1.0e-12
      coarse_solver_max_iterations = 1
      prolongation_method = "LINEAR_REFINE"
      restriction_method  = "CONSERVATIVE_COARSEN"
      hypre_solver {
         solver_type           = "PFMG"
         rap_type              = 0
         relax_type            = 2
         skip_relax            = 0
         num_pre_relax_steps   = 2
         num_post_relax_steps  = 2
         relative_residual_tol = 1.0e-12
         max_iterations        = 1
         enable_logging        = FALSE
      }
   }

   VankaFACSolver {
      num_pre_sweeps  = 2
      num_post_sweeps = 2
      coarse_solver_choice = "block_jacobi"
      coarse_solver_tolerance = 1.0e-12
      coarse_solver_max_iterations = 2
      U_prolongation_method = "CONSTANT_REFINE"
      P_prolongation_method = "CONSTANT_REFINE"
      U_restriction_method  = "CONSERVATIVE_COARSEN"
      P_restriction_method  = "CONSERVATIVE_COARSEN"
   }
}

RigidityConstraint {
  
  num_INS_cycles                     = NUM_INS_CYCLES //default 2 
  needs_divfree_projection           = TRUE           //default true
  filter_deformation_kinematics      = FALSE          //default false
  calculate_translational_momentum   = 1, 1, 1        // U, V, W
  calculate_rotational_momentum      = 1, 1, 1        // Omegax, Omegay, Omegaz
  body_is_partly_elastic             = FALSE          //default false
  maintain_log                       = TRUE           //default false
  rho_fluid                          = RHO
  mu_fluid                           = MU
  tag_global_lag_pt                  = 0                       //lag index to track, default 0
  lag_position_update_method         = "user_defined_velocity" // options are "user_defined_position", "user_defined_velocity"
                                                               // and "background_fluid_velocity"

  
  // set this database for classes derived from IBKinematics class.
  Kinematics {  
    body_name                         = "SPHERE3D"        //default "SWIMMING_BODY"
    vertex_file_dir                   = "./"
    vertex_filename                   = "sphere3d.vertex"
  }
  
  ElasticPartOfBody {
    
      starting_elastic_lag_idx    = -1  // -1 to indicate entire non-elastic domain.
  }

  
  
  PrintOutput {
    
      print_output                = TRUE    //default false, if false nothing will be printed.
      output_interval             = 1       //default 1
      output_drag_kinetic_energy  = TRUE    //default false, if false it will not be computed.
      output_power                = TRUE    //default false, if false it will not be computed.
      output_rig_transvel         = TRUE    //default false
      output_rig_rotvel           = TRUE    //default false
      output_com_coords           = TRUE    //default false
      output_moment_inertia       = TRUE   //default false
      
      output_dirname              = "./Output_sphere3d_rotation"
      base_filename               = "sphere3d"
  }                 


}

ForceProjector {

 rho_fluid = RHO
 rho_solid = rho_fluid
 gravitational_constant = 0.0,-9.81/2.0, 0.0

}


Main {
// log file parameters
   log_file_name    = "IB3d_sphere3d.log"
   log_all_nodes    = FALSE

// visualization dump parameters
   viz_writer            = "VisIt" 
   viz_dump_interval       = 40    //zero to turn off
   viz_dump_dirname      = "viz_sphere3d_rotation"
   visit_number_procs_per_file = 1

// restart dump parameters
   restart_interval      = 0                 // zero to turn off
   restart_write_dirname = "restart_IB3d"

// hierarchy data dump parameters
   hier_dump_interval = 0                   // zero to turn off
   hier_dump_dirname  = "hier_data_IB3d"

// timer dump parameters
   timer_dump_interval   = 0                 // zero to turn off

// post processor parameters
   postprocess_interval = 0                  // zero to turn off
}

CartesianGeometry {
   domain_boxes = [ (0,0,0) , (10 - 1 , 16 - 1, 10 - 1) ]
   x_lo         = -1.0, -7.0, -1         // lower end of computational domain.
   x_up         =  1.0,  1.0,  1         // upper end of computational domain.
   periodic_dimension = 0, 0, 0
}

GriddingAlgorithm {
   allow_patches_smaller_than_minimum_size_to_prevent_overlaps = TRUE
   coalesce_boxes = TRUE

   max_levels = MAX_LEVELS           // Maximum number of levels in hierarchy.
   ratio_to_coarser {
      level_1 = 1*REF_RATIO,1*REF_RATIO, REF_RATIO  // vector ratio to next coarser level
      level_2 = REF_RATIO/2, REF_RATIO/2, REF_RATIO/2
      level_3 = REF_RATIO_FINEST,REF_RATIO_FINEST,REF_RATIO_FINEST 
      level_4 = REF_RATIO_FINEST,REF_RATIO_FINEST,REF_RATIO_FINEST
      level_5 = REF_RATIO_FINEST,REF_RATIO_FINEST,REF_RATIO_FINEST
   }

   largest_patch_size {
      level_0 =512,512, 512  // largest patch allowed in hierarchy
                             // all finer levels will use same values as level_0...
   }

   smallest_patch_size {
      level_0 = 8, 8, 8 // smallest patch allowed in hierarchy
                           // all finer levels will use same values as level_0...
   }

   efficiency_tolerance   = 0.85e0    // min % of tag cells in new patch level
   combine_efficiency     = 0.85e0    // chop box if sum of volumes of smaller
                                      // boxes < efficiency * vol of large box
}

StandardTagAndInitialize {
   tagging_method = "GRADIENT_DETECTOR"
}

LoadBalancer {
   bin_pack_method     = "SPATIAL"
   max_workload_factor = 1
}

TimerManager{
   print_exclusive = FALSE
   print_total = TRUE
   print_threshold = 0.1

   timer_list = "IBAMR::*::*" , "IBTK::*::*" , "*::*::*"
}
